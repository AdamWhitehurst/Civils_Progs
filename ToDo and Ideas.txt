ToDo: Seperate into ideas(python) and ideas(quarry) so no more merge conflicts

Random idea:
Maybe have a "master" and "slave" function on the quarry shell so that you could just slave multiple turtles to be controlled by a computer. So you could push quarry configurations
 to individual turtles and view their progress through the quarry receiver.
-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-

Quarry Receiver x.x.x (matches current quarry):
  Add in "usage" parameter, because not even I can remember it. So like "usage", "help", "-help", "?" and "-?" bring up parameters.
  Add in a "themes" system accessible by the command line
  Ideas:
  1. All themes are in files in a "themes" folder.
  2. Some themes are included in the program code, and can be selected.
  3. Command line argument could just be a file name, then will search included themes.
  4. Layout for a "theme" file would just be "addColor(parameters)" for all the different styles. Maybe to be fancy you could have overrides on all different things, like give them an id and stuff
  5. Integration with shell: Interactive menu to design/choose theme. Maybe have a default themes-set to download.

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-

Quarry Shell 1.0.0:
Program that can read logs and make a configuration file to run quarry from.
Will feature an interactive menu where you can select start quarry, make configuration file, or read logs.
All menu items will be clickable/scrollable with mouse. Different types of menus:
  t/f can be changed with return key / arrow keys
  number can be changed with arrow keys, maybe just do a popup menu and only accept integers. Because channel 35346 will take a while to get to.
  text will open up a text box popup.
  
Will feature an interactive editor for configurations. It will be just like any other menu, but will have all possible parameters. 2 options for getting these:
  1. Have a list that you make (lazy)
  2. Have it search for "addParam" functions in the program and take parameters off of them.
Option: Either interactive editor or raw editor. Raw editor will just be a file that will be parsed and loaded as parameters.

Technical idea:
  Definately a standard menu design. Have different types and have menu functions for up, down, enter, back, selct index. This will make the menus really cool and seamless.
  So have a menu that interacts with different menu objects that can do different things if they are selected, clicked, etc.

"Then I have a plan for making an installer that will perform various tasks like installing latest versions, 
running pre-designated quarries (so like, load a set of parameters that you make in a file), reading quarry logs, 
and possibly doing multiple quarries/rooms/however you use its in a row (quarry, go left 60, quarry). 
So that will be cool."


Menu Plans (w/ sub menu):
  Run Default Quarry
  Configurations
    Run loaded configuration
      All different configurations
    Edit configuration
      All different configurations --Since both same, maybe function "loaded quarries menu" or something
    New configuration
  Setups --This is just a simple scripting file. Like a regular lua file except that when saved, things like "&config renault&" are replaced by "shell.run("quarry", args)"
    Run
    New
    Edit
      List of Configurations
  Receiver Configs (If has wireless modem)
    Default
    Run
      Menu
    Edit
      Menu
    New
  Themes (If advanced turtle/computer) --These will load a theme for the shell or reciever.
    Shell Themes
      Menu of installed
    Receiver Themes
      Menu of installed
    Install Theme
      Popup for pastebin code
  Read Logs
    List of logs
  Updates --If update found, will ask user if they want to overwrite files. Updates will include those to the shell itself, quarry, and quarryReceiver
    Update All
    Check Updates
    Select Updates
      Different updates possible
    Configure update source --Possibly just have this go through github. So then every new version I would push to master, then they could take dev versions from luaDev.
  Install/Register Components
    Different components not installed --Installing here would register the program name
    Register Component. If you already have "quarry" installed, register it as "quarry" here so the program knows what to run.
  Misc/Deletions
    Delete config
    Delete setup
    edit settings
    tips/help
    
Arguments:
  -run [name]: This will run the selected script instead of launching gui
  -default: Will run the default quarry

How things might work:
  Setups:
    You would go into an editor, and you could type things like "forward()" and "left()" and regular shell commands. Then have special strings denoted by a character like "&" so "&config pizza" or something that would be replaced on save by a shell string of the pizza config file.
    Another Option: Instead you could have like "face 0; go right 10; run pizza; go right 10; run pizza; go left 20" and all of those would be replaced on save by more appropriate commands and loops.
  Read Logs:
    Maybe just have it be a centered menu with no identifiers (or only a small one), so they can be scrolled and stuff.
  You could reuse both the menu API and the arguments system from other projects. Also, you may look into using your colorPrint api as well for menus It would be cool
  
Way in future: Add session persistence for setups

Random future thoughts: Maybe make more seamless. Have an arg/option to make calling the program just start quarry with additional args supplied so like "shell -dim 5 5 5" would do the same as quarry

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-

Quarry Version 3.4.5:
Changelog so far:
  new constants: VARIABLE, originalDay, numResumed, both used in logging.


Things for 3.4.5:
  Improve drop function
  Improve drop function. Just... make it better in general. Also have an argument table of slots not to drop from.
  Add back in "oreQuarry" functionality.
  Make it so that the turtle will dump off all cobblestone it has before putting into chest. Maybe just do it on the fly.
  
Things to add for quarry version 3.5.0 (After rednet update and shell is done):
  Add support for mods. Like openperipheral chest finding.
  Improve end of layer logic. You should be able to just have it stop at the end of the layer and go down three with minimal hassle.
  With inclusion of certain slots not to drop or slots to drop all but one of, you could make a more ore-driven quarry that will only mine ores and things not on its list of stuff to not mine
  Fix up and down functions. They may work, and they may be clever, but they are really dumb.
  Maybe have a "-autoResume" or "-autoReotherTerm" parameter with string argument of what to rename other original startup to
  Maybe have seperate "goDown" and "goUp" parameters
    Or: Maybe just have an "offset" variable that could be positive or negative. -40 would go down 40 before it starts the quarry. Inverted or no.
  Maybe have an option to change the home position. Like at 1,1,1 instead of 0,1,1. You could just replace all the "goto 1,1,1 goto 0,1,1" with a "go home" command
  
-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
Ideas for a Remote Turtle:
  Turtle will have all commands on it, not the computer
  It will also have an interpreter to interpret commands as loops.
    E.G. Computer sends "forward 34" and the turtle interprets that as "for i=1, 34 do forward() end"
  Turtle will have many different settings for things it can do. Pressing different keys will bring up context menus for different settings
  Pressing "." and "," will cycle through the turtle's different inventory slots.
  Different buttons for place, down, up, attack, etc.
  Settings:
    Aggressiveness: No attack, one attack, kill
    Detect: None, Forward, 3 side, all side (will turn around a bunch)
    Mining: Do not mine, mine blocks in front, select sides (will open up a checklist)
    Track inventory: No, Selected Slot, All Slots
    Check if item fuel: Yes, No
  Buttons:
    Forward, Backward, Turn left, Turn Right, Up, Down
    Attack, Up, Down
    Dig, Up, Down
    Place, Up, Down
    Drop, Up, Down
    Refuel from slot
    Refuel all
    Open Console
  Maybe ability to switch between different turtles with another button.
  Maybe turtle will maintain a record of its detects and everywhere its been. Then you could make a map :D
  
-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
 
Plans for a tower program:
Make a program that fills in an X x Z x Until it hits ground hole. Will turn around, go up a certain number, then back one, then down until hits bottom, back up, place a block, and go up. Repeat this until gets to x. If last point will end in a down then will go to the bottom and place up. Keeps track of coordinates to go back to start.
Prolly just going to scrap this

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-

Plans for a Redstone Control Station:
Basically, make an api table that only has one function. This function returns an object that has all of the necessary methods for returning values and making new indexes. In the object, each numbered value will be a table that has paramaters for:
Title, default redstone, "On" text, "Off" text, color of title, background color of title, pulse t/f, pulse duration, cable color, and a "current" value, which is just redstone true of false right now.
The actual program will handle stuff like key presses, scrolling, adjusting redstone, and updating the screen.

Cool mockup in the notebook in your backpack.

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-

Ideas for minecraft word:
  Completely seperate the data from the visual. The data will conatain all of the lines (seperated by line breaks), and the visual will handle printing it in a formatted way for reading.
  Some day...
  