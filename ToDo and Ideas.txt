-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-

Quarry Receiver 3.3.0 (matches current quarry):

Program will just register items to display on receive. It will then print them in order if there is room. Each element will be a table containing the original value, the short value, the medium value,
 the long value, and a table containing the screenX required for all sizes. Maybe also have a priority (e.g. priority 1 will always disply, then priority two will display, then priority 3 will display if there is room.
 
 Reinstate the thing where you can give commands from the rednet program. Like stop, or drop off items.
 New cool way to implement this: When new event system gets implemented, add a coroutine that adds events to the event queue based on messages received.
 
 Ehh... I don't want to type all of my ideas, so here is an imgur link: http://i.imgur.com/EgDKyO4.jpg, http://i.imgur.com/84DDbbc.jpg
 
 One idea would be to have three different coroutines. One that handles sending and receiving messages, one that handles printing data to screen, and one that deals with typing commands. They will all share a universal data table for important information, all other variables are local.
 

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-

Quarry Shell 1.0.0:
Program that can read logs and make a configuration file to run quarry from.
Will feature an interactive menu where you can select start quarry, make configuration file, or read logs.

"Then I have a plan for making an installer that will perform various tasks like installing latest versions, 
running pre-designated quarries (so like, load a set of parameters that you make in a file), reading quarry logs, 
and possibly doing multiple quarries/rooms/however you use its in a row (quarry, go left 60, quarry). 
So that will be cool."

Menu Plans (w/ sub menu):
  Run Default Quarry
  Run loaded configuration
    All different configurations
  Edit configuration
    All different configurations --Since both same, maybe function "loaded quarries menu" or something
  New configuration
  Setups --This is just a simple scripting file. Like a regular lua file except that when saved, things like "&config renault&" are replaced by "shell.run("quarry", args)"
    Run
    New
  Read Logs
    List of logs
  Update components --If update found, will ask user if they want to overwrite files. Updates will include those to the shell itself, quarry, and quarryReceiver
  Download items --When given a pastebin, will check top for valid setup/config markings, and name it appropriately
    pastebin id
  Misc/Deletions
    Delete config
    Delete setup
    edit settings
    tips/help
    
Arguments:
  -run [config/setup] [name]: This will run the selected script instead of launching gui
  -default: Will run the default quarry

How things might work:
  Setups:
    You would go into an editor, and you could type things like "forward()" and "left()" and regular shell commands. Then have special strings denoted by a character like "&" so "&config pizza" or something that would be replaced on save by a shell string of the pizza config file.
    Another Option: Instead you could have like "face 0; go right 10; run pizza; go right 10; run pizza; go left 20" and all of those would be replaced on save by more appropriate commands and loops.
  Read Logs:
    Maybe just have it be a centered menu with no identifiers (or only a small one), so they can be scrolled and stuff.
  You could reuse both the menu API and the arguments system from other projects. Also, you may look into using your colorPrint api as well for menus It would be cool
  
Way in future: Add session persistence for setups

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-

Quarry Version 3.4.0:
Changelog so far:
  Changed "biometrics" function for new rednet
  Added in a few different calls to it.
  Added new parameter for goto: destination
  Fixed bug where it would error if run on a computer
  Added in rednet orders "Stop" and "Return" (case sensitive)
  Added biometrics calls in up and down

Things to add for quarry version 3.4.0 (Rednet update):
  Rednet support...

Things to add for quarry version 3.4.1:
  Use "for" loops for gps location checking on successful backup read --Cosmetic Change
  Do some fuel checking for all your different variables and how they affect things
  Maybe check so that if position gotten from GPS is different from stored, remove event queue.
  Add in a "-atChest" parameter that resets position to 0,1,1,0 and rowCheck to right
  See if you can change rowCheck "right" and "left" to true and false
  Suck it up and have bedrock just check if it detects a block. If you can't detect, its not bedrock.
  Have sanity check just put the turtle back on track. Like go back to layer start or something. If it gets called, pos system is working fine.
  Quotes: 
    "You could already do that if you want, though. Just put it in front of the chest and do "quarry -resume -manualPos 0 1 1 0". I'll add something like "-chestResume" or something as an alias for that, though.
    Ooh, also, I could try out having an "-offset" parameter. Since it oftentimes is off by one position, this parameter would offset the position saved by 1 / -1 or whatever number you put in. Then people could help me test to make it better :)  "
  Session Persistance: http://www.computercraft.info/forums2/index.php?/topic/13919-lama-location-aware-movement-api-v14/
  "This API only works on turtles that have a label and that use fuel. The label is required for state persistence, the fuel is used for checking whether the turtle finished a move that was interrupted by a forced shut down (game quit / chunk unloaded)." Credit Sangar, from Lama - Location Aware Movement API V1.4

  
Things to add for quarry version 3.5.0 (After rednet update and shell is done):
  Add support for mods. Like openperipheral chest finding.
  Improve drop function. Just... make it better in general. Also have an argument table of slots not to drop from.
  Improve end of layer logic. You should be able to just have it stop at the end of the layer and go down three with minimal hassle.
  With inclusion of certain slots not to drop or slots to drop all but one of, you could make a more ore-driven quarry that will only mine ores and things not on its list of stuff to not mine
  Fix up and down functions. They may work, and they may be clever, but they are really dumb.
  Maybe have a "-replaceStartup" parameter with string argument of what to rename other original startup to
  Maybe have seperate "goDown" and "goUp" parameters
    Or: Maybe just have an "offset" variable that could be positive or negative. -40 would go down 40 before it starts the quarry. Inverted or no.
  
-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
Ideas for a Remote Turtle:
  Turtle will have all commands on it, not the computer
  It will also have an interpreter to interpret commands as loops.
    E.G. Computer sends "forward 34" and the turtle interprets that as "for i=1, 34 do forward() end"
  Turtle will have many different settings for things it can do. Pressing different keys will bring up context menus for different settings
  Pressing "." and "," will cycle through the turtle's different inventory slots.
  Different buttons for place, down, up, attack, etc.
  Settings:
    Aggressiveness: No attack, one attack, kill
    Detect: None, Forward, 3 side, all side (will turn around a bunch)
    Mining: Do not mine, mine blocks in front, select sides (will open up a checklist)
    Track inventory: No, Selected Slot, All Slots
    Check if item fuel: Yes, No
  Buttons:
    Forward, Backward, Turn left, Turn Right, Up, Down
    Attack, Up, Down
    Dig, Up, Down
    Place, Up, Down
    Drop, Up, Down
    Refuel from slot
    Refuel all
    Open Console
  Maybe ability to switch between different turtles with another button.
  Maybe turtle will maintain a record of its detects and everywhere its been. Then you could make a map :D
  
-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
 
Plans for a tower program:
Make a program that fills in an X x Z x Until it hits ground hole. Will turn around, go up a certain number, then back one, then down until hits bottom, back up, place a block, and go up. Repeat this until gets to x. If last point will end in a down then will go to the bottom and place up. Keeps track of coordinates to go back to start.
Prolly just going to scrap this

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-

Plans for a Redstone Control Station:
Basically, make an api table that only has one function. This function returns an object that has all of the necessary methods for returning values and making new indexes. In the object, each numbered value will be a table that has paramaters for:
Title, default redstone, "On" text, "Off" text, color of title, background color of title, pulse t/f, pulse duration, cable color, and a "current" value, which is just redstone true of false right now.
The actual program will handle stuff like key presses, scrolling, adjusting redstone, and updating the screen.

Cool mockup in the notebook in your backpack.

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-

Ideas for minecraft word:
  Completely seperate the data from the visual. The data will conatain all of the lines (seperated by line breaks), and the visual will handle printing it in a formatted way for reading.
  Some day...
  
-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
Ideas for TTTClick:
  Using SysPrint(once it is done), make a menu that the program will come back to once it is done with a game/ at start of game.
  :D May get to work soon :D :D :D