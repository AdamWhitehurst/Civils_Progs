Random idea:
Maybe have a "master" and "slave" function on the quarry shell so that you could just slave multiple turtles to be controlled by a computer. So you could push quarry configurations
 to individual turtles and view their progress through the quarry receiver.
-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-

Quarry Receiver x.x.x (matches current quarry):
  Add in "usage" parameter, because not even I can remember it. So like "usage", "help", "-help", "?" and "-?" bring up parameters.
  Add in a "themes" system accessible by the command line
  Ideas:
  1. All themes are in files in a "themes" folder.
  2. Some themes are included in the program code, and can be selected.
  3. Command line argument could just be a file name, then will search included themes.
  4. Layout for a "theme" file would just be "addColor(parameters)" for all the different styles. Maybe to be fancy you could have overrides on all different things, like give them an id and stuff
  5. Integration with shell: Interactive menu to design/choose theme. Maybe have a default themes-set to download.
  6. Maybe prepend a random number to the sent string so a relay can differentiate messages.

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-

Quarry Shell 1.0.0:
Program that can read logs and make a configuration file to run quarry from.
Will feature an interactive menu where you can select start quarry, make configuration file, or read logs.
All menu items will be clickable/scrollable with mouse. Different types of menus:
  t/f can be changed with return key / arrow keys
  number can be changed with arrow keys, maybe just do a popup menu and only accept integers. Because channel 35346 will take a while to get to.
  text will open up a text box popup.
  
Will feature an interactive editor for configurations. It will be just like any other menu, but will have all possible parameters. 2 options for getting these:
  1. Have a list that you make (lazy)
  2. Have it search for "addParam" functions in the program and take parameters off of them.
Option: Either interactive editor or raw editor. Raw editor will just be a file that will be parsed and loaded as parameters.

Technical idea:
  Definitely a standard menu design. Have different types and have menu functions for up, down, enter, back, selct index. This will make the menus really cool and seamless.
  So have a menu that interacts with different menu objects that can do different things if they are selected, clicked, etc.

"Then I have a plan for making an installer that will perform various tasks like installing latest versions, 
running pre-designated quarries (so like, load a set of parameters that you make in a file), reading quarry logs, 
and possibly doing multiple quarries/rooms/however you use its in a row (quarry, go left 60, quarry). 
So that will be cool."


Menu Plans (w/ sub menu):
  Run Default Quarry
  Configurations
    Run loaded configuration
      All different configurations
    Edit configuration
      All different configurations --Since both same, maybe function "loaded quarries menu" or something
    New configuration
  Setups --This is just a simple scripting file. Like a regular lua file except that when saved, things like "&config renault&" are replaced by "shell.run("quarry", args)"
    Run
    New
    Edit
      List of Configurations
  Receiver Configs (If has wireless modem)
    Default
    Run
      Menu
    Edit
      Menu
    New
  Themes (If advanced turtle/computer) --These will load a theme for the shell or receiver.
    Shell Themes
      Menu of installed
    Receiver Themes
      Menu of installed
    Install Theme
      Popup for pastebin code
  Read Logs
    List of logs
      Read Log
        Pastebin put log
        Delete log
    Delete all logs
      Are you sure?
  Updates --If update found, will ask user if they want to overwrite files. Updates will include those to the shell itself, quarry, and quarryReceiver
    Update All
    Check Updates
    Select Updates
      Different updates possible
    Configure update source --Possibly just have this go through github. So then every new version I would push to master, then they could take dev versions from luaDev.
  Install/Register Components
    Different components not installed --Installing here would register the program name
    Register Component. If you already have "quarry" installed, register it as "quarry" here so the program knows what to run.
  Misc/Deletions
    Delete config
    Delete setup
    edit settings
    tips/help
    
Arguments:
  -run [name]: This will run the selected script instead of launching gui
  -default: Will run the default quarry

How things might work:
  Setups:
    You would go into an editor, and you could type things like "forward()" and "left()" and regular shell commands. Then have special strings denoted by a character like "&" so "&config pizza" or something that would be replaced on save by a shell string of the pizza config file.
    Another Option: Instead you could have like "face 0; go right 10; run pizza; go right 10; run pizza; go left 20" and all of those would be replaced on save by more appropriate commands and loops.
  Read Logs:
    Maybe just have it be a centered menu with no identifiers (or only a small one), so they can be scrolled and stuff.
  You could reuse both the menu API and the arguments system from other projects. Also, you may look into using your colorPrint api as well for menus It would be cool
  
  Each menu set is intricately tied with a table. e.g. The table controls all that goes on for that context menu, and just happens to have .text fields for all elements.
  The table would be passed a "parent table" by the previous menu so that each table can have a back button.
  
  In menu api, add in that each element can have a color and background color: either for the whole line or just where the text is.
  
Way in future: Add session persistence for setups

Random future thoughts: Maybe make more seamless. Have an arg/option to make calling the program just start quarry with additional args supplied so like "shell -dim 5 5 5" would do the same as quarry

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-

Quarry Version 3.5.3:
  General Ideas:
    maybe look for multiple "-forcePrompt setting" parameters, and each time one is found, 
add it to a table. When you do addParam function, check if on force prompt table, then prompt if so.
    instead of params being one-time, have them "register" a "listener" so that they can be called multiple times
Things for 3.5.3:
  Test what happens when turtle is out of fuel.
  In saveProgres, fix brute forcing the saveFile open
  Test mid-run refueling capabilities :)
  Test low-fuel behavior now

Things for 3.5.4:
  Organize all the things! Everything is so messy right now...
  Refactor quarryReceiver so that everything is generalized into classes. This will lead to having multiple screens: each in their own class with their own colors and attributes.
  Take out all the "str"s in the main loop of receiver
  In quarry tArgs, make a way to take out key value pairs in all forms
  
Things for 3.5.5:
  Maybe, on bottom line of receiver, have a couple buttons for drop, return, etc.
    Ooh! Maybe have "buttonHandler" table of functions that would make, place, activate, and deactivate buttons.
  
Things to add for quarry version 3.6.0 (After rednet update and shell is done):
  Add support for mods. Like open peripheral chest finding.
  Improve end of layer logic. You should be able to just have it stop at the end of the layer and go down three with minimal hassle.
  Fix up and down functions. They may work, and they may be clever, but they are really dumb.
  Maybe have a "-autoResume" or "-autoRestore" parameter with string argument of what to rename other original startup to
  Maybe have separate "goDown" and "goUp" parameters
    Or: Maybe just have an "offset" variable that could be positive or negative. -40 would go down 40 before it starts the quarry. Inverted or no.
  Maybe have an option to change the home position. Like at 1,1,1 instead of 0,1,1. You could just replace all the "goto 1,1,1 goto 0,1,1" with a "go home" command
  
-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
Ideas for a Remote Turtle:
  Turtle will have all commands on it, not the computer
  It will also have an interpreter to interpret commands as loops.
    E.G. Computer sends "forward 34" and the turtle interprets that as "for i=1, 34 do forward() end"
  Turtle will have many different settings for things it can do. Pressing different keys will bring up context menus for different settings
  Pressing "." and "," will cycle through the turtle's different inventory slots.
  Different buttons for place, down, up, attack, etc.
  Settings:
    Aggressiveness: No attack, one attack, kill
    Detect: None, Forward, 3 side, all side (will turn around a bunch)
    Mining: Do not mine, mine blocks in front, select sides (will open up a checklist)
    Track inventory: No, Selected Slot, All Slots
    Check if item fuel: Yes, No
  Buttons:
    Forward, Backward, Turn left, Turn Right, Up, Down
    Attack, Up, Down
    Dig, Up, Down
    Place, Up, Down
    Drop, Up, Down
    Refuel from slot
    Refuel all
    Open Console
  Maybe ability to switch between different turtles with another button.
  Maybe turtle will maintain a record of its detects and everywhere its been. Then you could make a map :D
  
-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-

Idea for a track layer:

Interface:
  Turtle will read track parameters from a file. The program will parse the file and record how much it has done for persistence.
  Files will read something like this: In this example, we want regular and powered tracks placed along a route, with torches placed periodically and redstone torches placed under the powered rails.
    define redstone 3 1 1 --redstone torches are type 3 in ender chest id 1 slot 1(for narcissistic turtles)
    define torch 4 1 2 --torches are type 4 in ender chest id 1 slot 2
    define rail 1 1 3-7 --rail type 1 is in ender chest 1 slots 3 through 7
    define rail 2 1 8-10 powered --rail type 2 is in ender chest 1 slots 8-9
    forward 100 3 2 15 1 --Go forward 100 blocks, alternating 3 track of type 2 and 15 track of type 1
    zigzag 20 1 1 --Do the "zigzag" function with repeating 1 track of type 1
    slope 20 5 up 4 1 1 2 --Slope function (maybe just pass the last arguments to move function), 20 blocks long, 1 block for every 5 blocks forward with 4 regular tracks, then a powered track
    


Function:
  The turtle will first parse the specified configuration as a set of directions.
  Core concepts:
    Turtle will keep track of inventory (maybe not use full stacks of items for keeping purposes)
    Turtle will have an ender chest to obtain resupplies (test if you can keep one item, then just pull all from chest)
      If above does not work properly, turtle may be narcissistic and pull items from certain slots
    Turtle will work out where it needs to place redstone torches for optimum powered rail coverage, and will smartly place them (know when it can't)
    File making system will be awesome, and may eventually have a GUI for making track systems.
    Just make the system as robust as possible.

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
 
Plans for a tower program:
Make a program that fills in an X x Z x Until it hits ground hole. Will turn around, go up a certain number, then back one, then down until hits bottom, back up, place a block, and go up. Repeat this until gets to x. If last point will end in a down then will go to the bottom and place up. Keeps track of coordinates to go back to start.
Prolly just going to scrap this

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-

Plans for a Redstone Control Station:
Basically, make an api table that only has one function. This function returns an object that has all of the necessary methods for returning values and making new indexes. In the object, each numbered value will be a table that has paramaters for:
Title, default redstone, "On" text, "Off" text, color of title, background color of title, pulse t/f, pulse duration, cable color, and a "current" value, which is just redstone true of false right now.
The actual program will handle stuff like key presses, scrolling, adjusting redstone, and updating the screen.

Cool mockup in the notebook in your backpack.

Each item will be brought in from an external file in a folder. These files will be sandboxed and spawn in a list object that will be inserted into the full list

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-

Ideas for minecraft word:
  Completely separate the data from the visual. The data will contain all of the lines (separated by line breaks), and the visual will handle printing it in a formatted way for reading.
  Some day...
  
-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-

Idea for a mod pack
  Make it so every installer adds its own entry into the versions json, and records it in the modpacks folder
  Make it so the mod switcher also switches the active profile to whatever was selected
  Make a mod pack maker :)

  Mod Pack Downloader:
  Make a python script that will download mods from a list of urls on pastebin
  The pastebin will be updated regularly by another python script
  So when they start it up, it will check the pastebin, compare it to the mods already had (maybe), then download new mods and put them in the right folder.
